
### Swarm Main Loop
Swarm is desinged and implemented to run a main loop for handling commands received from the controler and events generated by inner transports. This is to avoid introducing the synchronous primitives like Mutex<> into Swarm. The ownership of Swarm itself is taken by the task loop and a Swarm Controller is exposed as the Swarm API interface.





### Swarm Controller
Swarm Controller is the API interface of Swarm. To manipulate Swarm, we have to send a control command to Swarm main loop via a futures::mpsc::channel. The controller is actualy the sender part of the channel.

### Limitations

#### Swarm Dialer, to be done

Swarm should make outgoing connections by dialing the multiaddr of the peer specified by PeerId. There might be multiple multi-address for a PeerId, so that Swarm should dial multi addresses at the same time. Besides, the dialing procedure should be done asynchronously to avoid blocking Swarm main task loop. All these require a Dialer component should be implemented considerately for Swarm. Swarm Dialer should be able to manage asynchronous dialing tasks, check the connection limit and properly handle the dialing results.  

#### Event Bus

Swarm should have an event bus for publish/subscribe connection or sub-stream events generated internally. Thus applications could receive the notifications that they are interested in and possiblely they could react to.

#### Statistics

There are some statistics implemented, but not sufficient as we know.





## Getting started

In general, to use libp2p-rs, you would always create a Swarm object to access the low-level network:

Creating a swarm:



It takes five items to fully construct a swarm, the first is a go context.Context. This controls the lifetime of the swarm, and all swarm processes have their lifespan derived from the given context. You can just use context.Background() if you're not concerned with that.

The next argument is an array of multiaddrs that the swarm will open up listeners for. Once started, the swarm will start accepting and handling incoming connections on every given address. This argument is optional, you can pass nil and the swarm will not listen for any incoming connections (but will still be able to dial out to other peers).

After that, you'll need to give the swarm an identity in the form of a peer.ID. If you're not wanting to enable secio (libp2p's transport layer encryption), then you can pick any string for this value. For example peer.ID("FooBar123") would work. Note that passing a random string ID will result in your node not being able to communicate with other peers that have correctly generated IDs. To see how to generate a proper ID, see the below section on "Identity Generation".

The fourth argument is a peerstore. This is essentially a database that the swarm will use to store peer IDs, addresses, public keys, protocol preferences and more. You can construct one by importing github.com/libp2p/go-libp2p-peerstore and calling peerstore.NewPeerstore().

The final argument is a bandwidth metrics collector, This is used to track incoming and outgoing bandwidth on connections managed by this swarm. It is optional, and passing nil will simply result in no metrics for connections being available.



 

